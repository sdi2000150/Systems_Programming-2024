SystemProgramming-Spring2024-Project2
***************README****************

Όνομα: Θεόδωρος Μωραΐτης
UserID: sdi2000150 (1115202000150)

-------------------------------------------------------------------------------------------------------
Πρόγραμμα "jobNetworkExecutor" για την εκτελεση εργασιων που δινονται απο τον χρηστη πανω απο το δικτυο
                    (με χρηση Sockets, Threads, Condition Variables & Mutex)                    
-------------------------------------------------------------------------------------------------------
_______________________________________________________________________________
ΒΑΣΙΚΑ ΣΤΟΙΧΕΙΑ ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

-Το προγραμμα αποτελειται απο εναν jobCommander και εναν jobExecutorServer. Ο χρηστης μπορει να εκτελεσει εναν jobExecutorServer απο καποιο μηχανημα,
 και στη συνεχεια να εκτελεσει πολλαπλους jobCommanders απο αλλο ή αλλα μηχανηματα απομακρυσμενα. Το προγραμμα μπορει να τρεξει και τοπικα, με
 jobExecutorServer και jobCommanders να τρεχουν στο ιδιο μηχανημα (απλως δινοντας στους Commanders το "localhost" ως domain name του Server).

_______________________________________________________________________________
COMPILATION/EXECUTION ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

0) Για την μεταγλωττιση/εκτελεση/χρηση tests του προγραμματος, ειναι καλο ο χρηστης να βρισκεται στον πρωταρχικο καταλογο HW2.

1) Separate compilation του προγράμματος, με χρήση Makefile, στο tty μέσω της εντολής:
 > make
 ,με την οποία δημιουργουνται τα εκτελέσιμα "jobCommander" και "jobExecutorServer" εντος του bin καταλογου,
(τα object files δημιουργουνται εντος του build καταλογου).

2) Εκτέλεση του προγράμματος, ως εξης:
 2.1) Εκτελεση του jobExecutorServer, ως εξης:
    > ./bin/jobExecutorServer [portNum] [bufferSize] [threadPoolSize]

 2.2) Εκτελεση ενος ή περισσοτερων jobCommanders, ως εξης:
    > ./bin/jobCommander [serverName] [portNum] [jobCommanderInputCommand]

3) Clean των αρχειων που δημιουργήθηκαν μετά το compilation:
 > make clean

/*Σχόλια για τα ορισματα κατα την κληση των εκτελεσιμων:*/

-Παραπανω, το [jobCommanderInputCommand] ειναι οποιοδηποτε εκ των issueJob <job>, setConcurrency <N>, stop <jobID>, poll, exit.

-Ακομα και αν δωθει καποιο αλλο invalid ως πρωταρχικο command, το προγραμμα δουλευει κανονικα (απλως δεν κανει κατι για αυτο).

-Στην περιπτωση που δωθουν λανθασμενα ορισματα σε καθε εκαστοτε πρωταρχικο command, εχουν γινει καποιοι ελεγχοι εγγυροτητας.
 Για παραδειγμα αν δωθει setConcurrency bla, το προγραμμα θα αγνοησει το bla, και θα αφησει το Concurrency ιδιο. 

_______________________________________________________________________________
TESTS EXECUTION

-Εχω παρει τα tests απο την 1η εργασια και τα εχω τροποποιησει καταλληλα ωστε να τρεχουν και εδω. Επισης χρησιμοποιησα τα δυο bash scripts της 1ης εργασιας
 (allJobsStop.sh και multijob.sh), τα οποια τα τροποποιησα καταλληλα για να δουλευουν και εδω.

-Για να τρεξουν σωστα τα tests, οπως και με την κανονικη εκτελεση του προγραμματος, ειναι καλο ο χρηστης να βρισκεται στον πρωταρχικο καταλογο HW2.

-Για να δουλεψουν τα tests πρεπει ο χρηστης να ενημερωσει ολα τα tests με το domain name και port στα οποια εκτελει τον jobExecutorServer. 
 Για αρχη εχω βαλει ως domain name = localhost και ως listening port = 8881, με τα οποια δουλευουν κανονικα τα tests, απλα προυποθετουν οτι o
 jobExecutorServer τρεχει στο ιδιο μηχανημα (τοπικα) και ακουει στο port 8881.

_______________________________________________________________________________
SOURCE/HEADER FILES ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

jobCommander.c: Περιεχει ολη την υλοποιηση του jobCommander (δηλαδη την main). Ο jobCommander ειναι το προγραμμα με το οποιο αλληλεπιδρα ο χρηστης. 
                Μεσω του jobCommander ο χρηστης δινει εντολες στον jobExecutorServer για εκτελεση, και λαμβανει την αντιστοιχη απαντηση απο αυτον.

jobExecutorServer.c: Περιεχει μερος της υλοποιησης του jobExecutorServer, δηλαδη τα start routines του main thread, controller thread, worker thread,
                     καθως και αλλες τρεις βοηθητικες συναρτησεις, αλλα και τον singal handler που οριζεται για το SIGPIPE. Επισης περιεχει τον
                     ορισμο των shared-global data που θα χρησιμοποιηθουν απο τα threads του.
                     Ουσιαστικα περιεχει την main, δηλαδη την start routine αλλα και ολη την υλοποιηση της ουσιαστικης "δουλειας" του Main thread.
                     To Main thread του server τρεχει μια φορα και παραμενει ενεργο (ή σε κατασταση blocked οταν περιμενει για connection πανω στην accept) 
                     μεχρις οτου καποιο Controller thread λαβει command "exit" απο καποιον jobCommander, οπου τερματιζει ολο το process.

Controller.c: Περιεχει την συναρτηση controller, η οποια ειναι ολη την υλοποιηση της ουσιαστικης "δουλειας" του Controller thread.

Worker.c: Περιεχει την συναρτηση worker, η οποια ειναι ολη την υλοποιηση της ουσιαστικης "δουλειας" του Worker thread.

ServerInterface.h: Περιεχει τις δηλωσεις των δομων και συναρτησεων του jobExecutorServer. Επισης περιεχει την δηλωση των shared-global data ως extern,
                   ωστε τα υπολοιπα .c αρχεια που το κανουν include (Controller.c και Worker.c), να εχουν προσβαση σε αυτα.

CommonFunctions.c: Περιεχει την υλοποιηση καποιων βοηθητικων συναρτησεων, οι ο οποιες χρησιμοποιουνται ειτε απο τον jobCommander ειτε απο τον
                   jobExecutorServer (ειτε και απο τους δυο).

CommonInterface.h: Περιεχει την δηλωση των βοηθητικων συναρτησεων που υλοποιουνται στο CommonFunctions.c.

_______________________________________________________________________________
ΣΧΕΔΙΑΣΤΙΚΕΣ ΕΠΙΛΟΓΕΣ ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

-Χρησιμοποιησα Condition Variables και Mutex πανω σε shared data (global-heap) ως τον βασικο τροπο συγχρονισμου:
Condition Variables:"cond_full" (jobBuffer->count >= jobBuffer->bufferSize) && exit_commanded == false
                    "cond_emtpy" (jobBuffer->count <= 0 || running_jobs >= concurrencyLevel) && exit_commanded == false
                    "cond_exit" (controllers_running > 0)
Mutex: "mutex_shm" (ενα μονο, πανω σε ολα τα shared data)

-Οσον αφορα την λογικη του προγραμματος και στον τροπο που γινεται ο συγχρονισμος σε διαφορα σημεια:
-Για την εισαγωγη job στον buffer απο ενα controller thread και την εξαγωγη job απο τον buffer απο ενα worker thread χρησιμοποιω το
producer-consumer μοντελο συγχρονισμου (δηλαδη cond_full και cond_emtpy condition variables, ενα mutex, και εναν jobBuffer ο οποιος 
λειτουργει με κυκλικο τροπο, ειναι δηλαδη circular).
-To τελικo exit του προγράμματος το αναλαμβανει ενας controller (αυτος που ελαβε το exit), ο οποιος φροντιζει πριν κανει exit το process,
να εχουν τερματισει ολα τα υπολοιπα controller-threads, καθως και ολα τα worker-threads (αλλα και να εχουν ολοκληρωθει οι δουλειες που 
ετρεχαν). Επισης φροντιζει να καθαρισει τη μνημη και να κανει free και destroy οποιαδηποτε δομη ειχε χρησιμοποιηθει. 

-Κατα το exit του προγραμματος παρατηρουνται καποια μιδαμινα leaks (possibly lost: 272 bytes in 1 blocks), τα οποια ενδεχομενως να εχουν 
να κανουν με τον τροπο που γινεται exit (ισως καποια thread-local storages καποιων threads ή του main thread να μην απελευθερονονται).
Τα συγκεκριμενα leaks δεν επηρεαζουν την λειτουργικοτητα του προγραμματος.

-Xρησιμοποιησα το εξης πρωτοκολλο επικοινωνιας μεσω sockets:
Καθε ενας που γραφει σε socket, ειτε jobCommander ειτε jobExecutorServer, γραφει οτι θελει να στειλει με μια και μονο write. Αυτο γινεται για 
να μην δημιουργηθει προβλημα κατα το διαβασμα, αλλα κυριως γιατι ηταν ετοιμο το πρωτοκολλο απο την 1η εργασια.
Ετσι καθε ξεχωριστο μυνημα πρεπει να γινει concatanated σε ενα ολοκληρο string. Η αλλη πλευρα ξερει πως να κανει parse το συγκεκριμενο μυνημα,
αρα και να λαβει την χρησιμη πληροφορια.
Ουσιαστικα καθε φορα, πρωτα στελνεται ενας int που δειχνει το sizeofmessage που ακολουθει, ακολουθουμενος απο το υπολοιπα μυνημα. Ετσι,
ο δεκτης ξερει ποσα bytes προκειται να διαβασει μετα τον int.
Το συγκεκριμενο δεν συμβαινει στην περιπτωση του output response της issueJob (δηλαδη το 2ο response-output της εντολης που λαμβανει ο jobCommander οταν στελνει 
issueJob για εκτελεση). Εκει χρησιμοποιειται read() επαναληπτικα η οποια διαβαζει σε chunks μεγεθους DFLBUFSIZE, δηλαδη οσο στελνει και ο Server.

-Κατα το γραψιμο οποιουδηποτε αριθμου (στην περιπτωση sizeofmessage) πανω σε socket χρησιμοποιειται η συναρτηση htonl(),
και, αντιστοιχα, κατα το διαβασμα αριθμου απο socket χρησιμοποιειται η συναρτηση ntohl().
Για το υπολοιπο, ουσιαστικο, μυνημα δεν χρησιμοποιουνται οι συγκεκριμενες, μιας και γραφονται strings (ακολουθια chars), δηλαδη chars του 1 bytes το 
καθενα ως τυπος, που δεν εχει προβλημα στη δικτυακη επικοινωνια διαφορετικων αρχιτεκτονικων συστηματων.

-Κατα την ικανοποιηση της εντολης issueJob <job>, ως delimeter του job, χρησιμοποιησα το κενο (" "). 
Για αυτο και αν δωθει command μετα την issueJob που περιεχει κενο ως μερος της εντολης (πχ καποιο file με ονομα με κενα), 
τοτε το προγραμμα δεν μπορει να ανταπεξελθει, και θα αποτυχει.

-Κατα την ικανοποιηση της εντολης issueJob <job>, αν το job περιεχει οποιονδηποτε απο τους εξης χαρακτηρες ;|&`><$(){}[]*?~
, τοτε αυτοι δεν λαμβανονται υποψην, και εκτελειται (αν δουλεψει ετσι) η εντολη χωρις αυτους. Για αυτο ειναι υπευθυνη η 
συναρτηση sanitize(), και ο χρηστης (προγραμματιστης) μπορει να αλλαξει/τροποποιησει το συνολο αυτο των απαγορευμενων συμβολων
για εκτελεση. Το συγκεκριμενο γινεται για λογους ασφαλειας, μιας και ο Server θα εκτελεσει οποιαδηποτε εντολη του δωσει ο
Commander, και για αυτο πρεπει να προνοησει και να μην αφησει να εκτελεστουν επικινδυνες εντολες (πχ ls ; rm *).

-Χρησιμοποιησα Posix Signal Handling για την περιπτωση του σηματος SIGPIPE. Το συγκεκριμενο δεν ειναι κατι το οποιο ηταν αναγκαιο,
μιας και ο τροπος υλοποιησης του jobCommander ειναι τετοιος που δεν προκειται να προκαλεσει SIGPIPE error στον jobExecutorServer.
Ωστοσο, σαν καλη πρακτικη προγραμματισμου, ειναι καλο ο Server να μην τερματιζει με καποιο SIGPIPE για το οποιο ευθυνεται καποιος
υποτιθεμενος jobCommander ο οποιος εκλεισε το socket πριν λαβει αποτελεσμα απο τον Server.

-Στο προγραμμα αντι για read(), εφτιαξα και χρησιμοποιησα μια συναρτηση myread(), η οποια καλει την read() επαναληπτικά μεχρι να διαβαστουν
ολα τα ζητουμενα bytes. Το συγκεκριμενο δεν ειναι κατι το οποιο ηταν αναγκαιο, μιας και το προγραμμα εγγυαται ακριβως τα bytes που θα διαβασει
η καθε read να ειναι σωστα, ωστοσο ειναι καλη πρακτικη προγραμματισμου, μιας και διαφορα πραγματα μπορει να επιδρασουν στην εκτελεση των syscalls,
και ειδικα της read(), (πχ signal interruption, data were written in chunks, etc...).

-Ο κωδικας ειναι πληρως εφοδιασμενος με σχολια. Επισης, εχω αφησει σε σχολια διαφορες printf βοηθητικες για την εκτελεση του προγραμματος,
οι οποιες μπορουν ανα πασα στιγμη να αποσχολιαστουν για debugging/checking της ροης/κλπ.
