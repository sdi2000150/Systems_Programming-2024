SystemProgramming-Spring2024-Project1
***************README****************

Όνομα: Θεόδωρος Μωραΐτης
UserID: sdi2000150 (1115202000150)

-----------------------------------------------------------------------------
Πρόγραμμα "jobExecutor" για την εκτελεση εργασιων που δινονται απο τον χρηστη
    (με χρηση Named Pipes, Posix Signals, Low-Level I/O, Bash Scripting)    
-----------------------------------------------------------------------------
_______________________________________________________________________________
ΒΑΣΙΚΑ ΣΤΟΙΧΕΙΑ ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

-ΒΑΣΙΚΗ ΠΡΟΥΠΟΘΕΣΗ για να τρεξει το προγραμμα χωρις προβληματα ειναι να τρεξει πρωτα μια φορα μονος του
ενας ./jobCommander (με οποιαδηποτε εντολη, εκτος της exit προφανως ωστε να εχει νοημα), ουτως ωστε να
αρχισει να τρεχει ο jobExecutorServer και να αρχικοποιησει καποια πραγματα χωρις προβληματα (βασικα αυτο 
ειναι σημαντικο ωστε να δημιουργηθει ο jobExecutorServer μια φορα (με fork/exec), αλλα και το αρχειο 
jobExecutorServer.txt, χωρις race condition σε καθε περιπτωση).

-ΑΡΑ, καθε φορα που τρεχουμε εκ νεου το προγραμμα (δηλαδη εχει προηγηθει καποιο exit command ή ειναι η
πρωτη φορα που τρεχουμε το προγραμμα), ΠΡΕΠΕΙ να εκτελειται μια φορα μονος του o jobCommander (χωρις 
αλλους jobCommanders ταυτοχρονα, ή μεσα σε script κλπ).

-Εφοσον δημιουργηθει ο jobExecutorServer και αρχιζει και τρεχει, μετα ειναι αποδεκτο και λειτουργικο να
μπορουν πολλαπλοι jobCommanders να τρεχουν παραλληλα/μεσα απο scripts/κλπ.

_______________________________________________________________________________
COMPILATION/EXECUTION ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

1) Separate compilation του προγράμματος, με χρήση Makefile, στο tty μέσω της εντολής:
 > make
 ,με την οποία δημιουργουνται τα εκτελέσιμα "jobCommander" και "jobExecutorServer".

2) Εκτέλεση του προγράμματος, ως εξης:
 
 2.1) Πρωτη εκτελεση του jobCommander, ωστε να δημιουργηθει και να αρχικοποιηθει ο jobExecutorServer:
  > ./jobCommander "command"
  ή αυτοματοποιημενα μεσω:
  > make start
  οπου απλα τρεχει ./jobCommander start (δηλαδη με μια invalid command, απλα για να αρχικοποιηθει ο server)

 2.2) Επομενες εκτελεσεις του jobCommander, ειτε σειριακα εναν την φορα:
 > ./jobCommander "command"
 ειτε παραλληλα:
 > ./jobCommander "command1" & ./jobCommander "command2" & ./jobCommander "command3" & ...
 ειτε αυτοματοποιημενα μεσω scripts, πχ:
 > ./tests/test_jobExecutor_1.sh

3) Clean των αρχειων που δημιουργήθηκαν μετά το compilation/execution:
 > make clean

4) Για γρηγορη εκτελεση με valgrind μια τυχαιας, invalid, εντολης (οπως ειπαμε παραπανω, για την αρχικοποιηση του προγραμματος):
 > make start

5) Για γρηγορη εκτελεση με valgrind του command "exit":
 > make exit

/*Σχόλια για τα ορισματα κατα την κληση των εκτελεσιμων:*/

-Παραπανω, το "command" ειναι οποιοδηποτε εκ των issueJob <job>, setConcurrency <N>, stop <jobID>, poll [running,queued], exit.

-Ακομα και αν δωθει καποιο αλλο invalid ως πρωταρχινο command, το προγραμμα δουλευει κανονικα (απλως δεν κανει κατι για αυτο).

-Δεν υπαρχει εγγυηση για την συμπεριφορα του προγραμματος στην περιπτωση που δωθουν λανθασμενα ορισματα σε καθε εκαστοτε πρωταρχικο
command. Για παραδειγμα αν δωθει setConcurrency bla, δεν υπαρχει εγγυηση οτι το προγραμμα θα συνεχισει να εκτελειται σωστα.

_______________________________________________________________________________
SOURCE/HEADER FILES ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

jobCommander.c: Περιεχει ολη την υλοποιηση του jobCommander (δηλαδη την main), καθως και τον singal handler που οριζει για το SIGUSR1.
                Ο jobCommander ειναι το προγραμμα με το οποιο αλληλεπιδρα ο χρηστης. Μεσω του jobCommander ο χρηστης δινει εντολες στον 
                jobExecutorServer για εκτελεση. Ο 1ος jobCommander που τρεχει ειναι αυτος που δημιουργει (με fork/exec) τον jobExecutorServer,
                και επειτα του στελνει την εντολη προς εκτελεση και λαμβανει απαντηση απο αυτον. Οι επομενοι jobCommanders που καλουνται 
                απλα στελνουν την εκαστοτε εντολη προς εκτελεση και λαμβανουν την αντιστοιχη απαντησ απο αυτον.

jobExecutorServer.c: Περιεχει ολη την υλοποιηση του jobExecutorServer (δηλαδη την main), καθως και τους singal handler που οριζει για τα
                     SIGUSR1, SIGUSR2, SIGCHLD. Τρεχει μια φορα, και παραμενει ενεργος (ή σε κατασταση suspension οταν δεν κανει καποια δουλεια)
                     μεχρις οτου να λαβει command "exit" απο καποιον jobCommander, οπου τερματιζει. Ειναι υπεθυνος για την ληψη εντολων απο 
                     τους jobCommanders και εκτελεση αυτων, καθως και για την επιστροφη των αντιστοιχων responses στους jobCommanders.

QueueFunctions.c: Περιεχει την υλοποιηση των συναρτησεων της δομης Queue.

ExtraFunction.c: Περιεχει την υλοποιηση καποιων εξτρα, βοηθητικων, συναρτησεων.

MyHeader.h: Περιεχει την δηλωση των δομων και των συναρτησεων της Queue, καθως και την δηλωση καποιων εξτρα συναρτησεων.

_______________________________________________________________________________
BASH SCRIPTS ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

multijob.sh: Για καθε file.txt που παιρνει σαν ορισμα, προσπελαυνει τα περιεχομενα του, γραμμη-γραμμη, και εκτελει απευθειας
             την εκαστοτε εντολη ανα γραμμη, με ./jobCommander issueJob.

allJobsStop.sh: Αρχικα τρεχει τον jobCommander με τις εντολες poll running και poll queued, ανακατευθυνοντας το output τους 
                σε ενα δυο .txt αρχεια αντιστοιχα (running_jobs.txt και queued_jobs.txt αντιστοιχα). Επειτα, για καθε .txt,
                προσπελαυνει τα περιεχομενα του, γραμμη-γραμμη, και καθε φορα κανει parsing/extract την υποσυμβολοσειρα job_ID
                απο ολοκληρη την συμβολοσειρα της γραμμης (<job_ID,job,queuePosition>). Ετσι, γνωριζοντας το job_ID, εκεινη τη
                στιγμη εκτελει απευθειας την εντολη ./jobCommander stop job_ID. Ετσι, ολες οι running και queud jobs σταματανε
                αμεσως.

_______________________________________________________________________________
ΣΧΕΔΙΑΣΤΙΚΕΣ ΕΠΙΛΟΓΕΣ ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

-Χρησιμοποιησα ενα κοινο pipe για την επικοινωνια απο τους jobCommanders (Clients) στον jobExecutorServer (Server).

-Χρησιμοποιηση πολλαπλα pipes, ενα καθε jobCommander (Client), για την επικοινωνια απο τον Server προς τον αντιστοιχο Client.

-Χρησιμοποιησα Signals και Posix Signal Handling ως τον βασικο τροπο συγχρονισμου.

-Ο κωδικας ειναι πληρως εφοδιασμενος με σχολια. Επισης, εχω αφησει σε σχολια διαφορες printf βοηθητικες για την εκτελεση του προγραμματος,
οι οποιες μπορουν ανα πασα στιγμη να αποσχολιαστουν για debugging/checking της ροης/κλπ. Ωστοσο, αν αποσχολιαστουν, και δημιουργηθουν νεες 
εκτυπωσεις κατα την εκτελεση, τοτε θα υπαρχει προβλημα με την εκτελεση του bash script allJobsStop.sh

-Tο queue position στην waiting queue ενημερωνεται με βαση τις οδηγιες. Απο την αλλη το queue position στην running queue 
ειναι απλως η θεση που ειχε η job οταν ηταν στην waiting queue.

-Χρησιμοποιησα sigwait() στην περιπτωση που ο Server περιμενει SIGUSR1 απο τον CLIENT (ή SIGCHLD απο καποιο παιδι). Απο την αλλη χρησιμοποιησα 
sigsuspend() στην περιπτωση που ο Server περιμενει SIGUSR2 απο τον CLIENT.

-Στο προγραμμα αντι για read(), εφτιαξα και χρησιμοποιησα μια συναρτηση myread(), η οποια καλει την read() επαναληπτικά μεχρι να διαβαστουν
ολα τα ζητουμενα bytes. Αυτο ειναι απαραιτητο απο την στιγμη που χρησιμποιουνται pipes και signals, τα οποια επιδρουν στην εκτελεση των syscalls,
και ειδικα της read(), (πχ signal interruption, pipe data were written in chunks, etc...).

-To jobExecutor.txt, το οποιο περιεχει το pid του jobExecutorServer, δεν ειναι σε text-readable μορφη, αλλα ειναι σε binary αποθηκευμενο pid_t.

-Xρησιμοποιησα το εξης πρωτοκολλο επικοινωνιας μεσω named pipes-FIFOs:
Καθε ενας που γραφει σε pipe, ειτε jobCommander ειτε jobExecutorServer, γραφει οτι θελει να στειλει με μια και μονο write. Αυτο γινεται για 
να μην δημιουργηθει προβλημα, ειδικα στην περιπτωση χρησης του κοινου pipe Clients-To-Server, και μπλεχτουν διαφορετικα μυνηματα μεταξυ τους.
Ετσι καθε ξεχωριστο μυνημα πρεπει να γινει concatanated σε ενα ολοκληρο string. Η αλλη πλευρα ξερει πως να κανει parse το συγκεκριμενο μυνημα,
αρα και να λαβει την χρησιμη πληροφορια.
Ουσιαστικα καθε φορα, πρωτα στελνεται ενας int που δειχνει το sizeofmessage που ακολουθει, ακολουθουμενος απο το υπολοιπα μυνημα. Ετσι,
ο δεκτης ξερει ποσα bytes προκειται να διαβασει μετα τον int.

-Ως delimeter του job, χρησιμοποιησα το κενο (" "). Για αυτο και αν δωθει command μετα την issuJob που περιεχει κενο ως μερος της εντολης
(πχ καποιο file με ονομα με κενα), τοτε το προγραμμα δεν μπορει να ανταπεξελθει, και θα αποτυχει.

-Για να τρεξουν τα scripts για testing που δωθηκαν πρεπει να προσθεθει το . στο enviroment variable PATH (export PATH=${PATH}:.)
ή να αλλαξουν τα progDelay σε ./progDelay εντος των testing scripts, δηλαδη οπου υπαρχει issueJob progDelay, να γινει issueJob ./progDelay.
Επισης αναλογως σε ποιο directory βρισκονται τα test scripts σε σχεση με τα εκτελεσιμα, θα πρεπει να προστεθει το αντιστοιχο relative
path. Πχ εχω βαλει τα test scripts σε εναν φακελο tests (ο οποιος βρισκεται στο ιδιο directory με τα προγραμματα μου), αρα αλλαξα τα 
progDelay εντος τους σε ./tests/progDelay.

_______________________________________________________________________________
ΠΑΡΑΔΟΧΕΣ ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ:

-Οπως ανεφερα και στην αρχη, πριν τρεξει κανεις οτιδηποτε σαν αυτοματοποιημενη/παραλληλη εντολη, πρεπει να τρεξει 
ο jobCommander μια φορα, ωστε αποφευχθει race condition στην δημουργια του jobExecutorServer αλλα και του file jobExecutorServer.txt

-Το προγραμμα δουλευει κανονικα οσον αφορα την παραλληλια σε επιπεδο εργασιων, δηλαδη jobs που δινονται με την
εντολη issueJob. Οσον αφορα την παραλληλια σε επιπεδο jobCommanders, δουλευει απλως δεν ειναι εγγυημενο οτι θα τρεξει παντα
πληρως ορθα ή οτι δεν θα δημιουργηθουν προβληματα, κλπ. Η φυση των Signals ως IPC ειναι αυτη που δημιουργει τα πιθανα προβληματα.